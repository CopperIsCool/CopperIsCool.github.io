<script>
const GODOT_CONFIG = {
    "args": [],
    "canvasResizePolicy": 2,
    "ensureCrossOriginIsolationHeaders": true,
    "executable": "index",
    "experimentalVK": false,
    "fileSizes": {
        "index.zip": 43016933
    },
    "focusCanvas": true,
    "gdextensionLibs": []
};
const GODOT_THREADS_ENABLED = false;
const engine = new Engine(GODOT_CONFIG);

(function () {
    const statusOverlay = document.getElementById('status');
    const statusProgress = document.getElementById('status-progress');
    const statusNotice = document.getElementById('status-notice');

    let initializing = true;
    let statusMode = '';

    function setStatusMode(mode) {
        if (statusMode === mode || !initializing) {
            return;
        }
        if (mode === 'hidden') {
            statusOverlay.remove();
            initializing = false;
            return;
        }
        statusOverlay.style.visibility = 'visible';
        statusProgress.style.display = mode === 'progress' ? 'block' : 'none';
        statusNotice.style.display = mode === 'notice' ? 'block' : 'none';
        statusMode = mode;
    }

    function setStatusNotice(text) {
        while (statusNotice.lastChild) {
            statusNotice.removeChild(statusNotice.lastChild);
        }
        const lines = text.split('\n');
        lines.forEach((line) => {
            statusNotice.appendChild(document.createTextNode(line));
            statusNotice.appendChild(document.createElement('br'));
        });
    }

    function displayFailureNotice(err) {
        console.error(err);
        if (err instanceof Error) {
            setStatusNotice(err.message);
        } else if (typeof err === 'string') {
            setStatusNotice(err);
        } else {
            setStatusNotice('An unknown error occured');
        }
        setStatusMode('notice');
        initializing = false;
    }

    // Fetch the ZIP file instead of .wasm
    fetch('index.zip')
        .then(response => response.arrayBuffer()) // Get the ZIP file as ArrayBuffer
        .then(data => {
            // Extract files from the ZIP
            JSZip.loadAsync(data).then(zip => {
                // Here, you can extract the files you need from the ZIP (e.g., index.wasm)
                zip.file('index.wasm').async('arraybuffer').then(wasmData => {
                    // Create a Blob URL for the extracted .wasm file
                    const wasmBlob = new Blob([wasmData], { type: 'application/wasm' });
                    const wasmUrl = URL.createObjectURL(wasmBlob);
                    // Now you can use the wasmUrl to load it into your game engine or application
                    engine.startGame({
                        onProgress: function (current, total) {
                            if (current > 0 && total > 0) {
                                statusProgress.value = current;
                                statusProgress.max = total;
                            } else {
                                statusProgress.removeAttribute('value');
                                statusProgress.removeAttribute('max');
                            }
                        },
                        wasmUrl: wasmUrl // Pass the Blob URL to the engine
                    }).then(() => {
                        setStatusMode('hidden');
                    }, displayFailureNotice);
                });
            }).catch(displayFailureNotice);
        })
        .catch(displayFailureNotice);
}());
</script>
